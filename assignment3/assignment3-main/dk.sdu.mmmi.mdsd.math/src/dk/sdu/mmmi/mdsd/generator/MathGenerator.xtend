/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.emf.ecore.EObject
import dk.sdu.mmmi.mdsd.math.ExternalDeclaration
import java.util.List
import java.util.Stack
import java.util.Set
import java.util.HashSet
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.ExternalCall
import dk.sdu.mmmi.mdsd.math.Expression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	override doGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = input.allContents.filter(MathExp).next
		math.generateJavaFile(fsa)
	}
		
	def void generateJavaFile(MathExp file, IFileSystemAccess2 fsa){
		var content = file.generateJavaCode
		fsa.generateFile(file.name + ".java", content)
	}
	
	def String generateJavaCode(MathExp file){
		return '''
		package math_expression.test;
		
		public class «file.name» {
			«IF file.isThereExternals»
				«file.externalFunctions.generateInterface»
			«ENDIF»
			
			«FOR varBind : file.variables SEPARATOR "\n"»
				public int «varBind.name»;
			«ENDFOR»
			
			«IF file.isThereExternals»
				private External external;
				
				public «file.name» (External external) {
					this.external = external;
				}
			«ENDIF»
			
			public void compute() {
				«FOR varBind : file.variables»
				«varBind.name» = compute«varBind.name.toFirstUpper»();
				«ENDFOR»
			}
			
			«FOR varBind : file.variables SEPARATOR "\n\n"»
			«varBind.generateComputeFunction»
			«ENDFOR»
		}
		'''
	}
	
	def String generateInterface(List<ExternalDeclaration> externalFuncs) {
		return '''
		interface External {
			«FOR exFunc : externalFuncs»
			int «exFunc.name»(«exFunc.generateParamList»);
			«ENDFOR»
		}
		'''
	}
	
	def String generateParamList(ExternalDeclaration external) {
		var res = "";
		var initialChar = 109;
		
		for (var i = 0; i < external.parameters.size; i++) {
			res += "int " + (initialChar + i) as char;
			
			if (i < external.parameters.size-1){
				res += ", "
			}
		}
		
		return res;
	}
	
	def String generateComputeFunction(VarBinding varBind) {
		return '''
			private int compute«varBind.name.toFirstUpper»() {
				«GenerateCompute.generateCompute(varBind.expression)»
			}
		'''
	}
	
	def boolean isThereExternals(MathExp file) {
		return file.externalFunctions.size > 0
	}	
}